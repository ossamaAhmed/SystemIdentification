function [p2_a_ex1, p2_b_ex1,p2_a_ex2, p2_b_ex2, p2_mse_ex1, p2_mse_ex2] = HS2019_SysID_final_p2_18936872()
%% Solution for Problem 1
screensize = get(groot, 'ScreenSize');
screenwidth = screensize(3);
screenheight = screensize(4);
figure_num = 1;
%% Generate data
fprintf('------------------------------------------------------------------\n');
fprintf('--------------------TASK ONE--------------------------------------\n');
fprintf('------------------------------------------------------------------\n');
fprintf('The estimate obtained with the least squares estimates is biased indeed since,\n');
fprintf('our model is A(z)y(k)=B(z)u(k)+A(z)e(k), therefore e(k) is not iid noise in this case\n');
fprintf('which makes the least square estimates to be biased since it undermines how the noise is correlated, underestimating the noise\n');
fprintf('On the other hand, the instrumental variables estimates obtained here are unbiased since we are using different input data to generate\n');
fprintf('the instruments which are supposed to have less correlation with the noise and high correlation with the output\n');
fprintf('Since we are using the least square estimate from the first data of the experiment to generate the instrumental variables using the second dataset\n');
% Extract Legi from Filename
name=mfilename;
LegiNumber= name(end-7:end);

% generate data
[p2_u1,p2_u2,p2_u_cv,p2_y1,p2_y2,p2_y_cv] = HS2019_SysID_final_p2_GenerateData(LegiNumber);

%% General instructions for solution

% Change the filename of this function, both in the function definition
% above and in the filename in the folder

% Use the variables p2_y and p2_u to solve the problem. 

% Modify your code in the next sections, and return the variables
% requested.

% If you skip one part of the problem, return the empty vectors as already
% provided in the code

%% Part 1
% Compute parameter estimates using instruments generated by least squares
% regression of the data
%-----------------------------------------------------------------------
%inspecting the output and input first
%-----------------------------------------------------------------------
% figure(figure_num);
% figure_num = figure_num + 1;
% fig = gcf;
% fig.Position = [mod(figure_num,2)*screenwidth/2, 0, screenwidth/2, screenheight];
% plot(p2_u1);
% hold on;
% plot(p2_y1);
% axis tight;
% axes = gca;
% axes.Title.Interpreter = 'latex';
% axes.Title.String = 'Input vs. Output';
% axes.Title.FontSize = 18;
% axes.XAxis.TickLabelInterpreter = 'latex';
% axes.XAxis.FontSize = 10;
% axes.YAxis.TickLabelInterpreter = 'latex';
% axes.YAxis.FontSize = 10;
% axes.XLabel.Interpreter = 'latex';
% axes.XLabel.String = '$k$ $[samples]$';
% axes.XLabel.FontSize = 14;
% lgd = legend('$u(k)$', '$y(k)$');
% lgd.Interpreter = 'latex';
% lgd.FontSize = 12;
% lgd.Location = 'southwest';
%-----------------------------------------------------------------------
%Computing the least square estimate
%-----------------------------------------------------------------------
N = length(p2_y1);
Phi = zeros(N, 5);
Phi(2, :) = [-p2_y1(1) 0 0 p2_u1(1) 0];
Phi(3, :) = [-p2_y1(2) -p2_y1(1) 0 p2_u1(2) p2_u1(1)];
for k = 4:N
    Phi(k, :) = [-p2_y1(k-1) -p2_y1(k-2) -p2_y1(k-3) p2_u1(k-1) p2_u1(k-2)];
end

%using LS estimate
theta_LS = Phi \ p2_y1;
a1LS = theta_LS(1);
a2LS = theta_LS(2);
a3LS = theta_LS(3);
b1LS = theta_LS(4);
b2LS = theta_LS(5);
z = tf('z');
G = ((b1LS / z) + (b2LS / z^2)) / (1 + a1LS / z + a2LS / z^2 + a3LS / z^3);


%getting Instrumental Variables Now
N = length(p2_y2);
Phi = zeros(N, 5);
Phi(2, :) = [-p2_y2(1) 0 0 p2_u2(1) 0];
Phi(3, :) = [-p2_y2(2) -p2_y2(1) 0 p2_u2(2) p2_u2(1)];
for k = 4 : N
    Phi(k, :) = [-p2_y2(k-1) -p2_y2(k-2) -p2_y2(k-3) p2_u2(k-1) p2_u2(k-2)];
end
x = lsim(G, p2_u2);
eta = zeros(5, N);
Rk = zeros(5);
eta_y = zeros(5, 1);
eta(:,2) = [-x(1); 0; 0; p2_u2(1); 0];
Rk = Rk + eta(:,2) * Phi(2,:);
eta_y = eta_y + eta(:,2) * p2_y2(2);
eta(:,3) = [-x(2); -x(1); 0; p2_u2(2); p2_u2(1)];
Rk = Rk + eta(:,3) * Phi(3,:);
eta_y = eta_y + eta(:,3) * p2_y2(3);
for k = 4 : N
    eta(:,k) = [-x(k-1); -x(k-2); -x(k-3); p2_u2(k-1); p2_u2(k-2)];
    Rk = Rk + eta(:,k) * Phi(k,:);
    eta_y = eta_y + eta(:,k) * p2_y2(k);
end

Rk = Rk / N;
eta_y = eta_y / N;

thetaIV = Rk \ eta_y;
%-----------------------------------------------------------------------
%Self Validation Now
%-----------------------------------------------------------------------
y_estimated = Phi * thetaIV;
estimation_error = p2_y2 - y_estimated;
% figure(figure_num);
% figure_num = figure_num + 1;
% fig = gcf;
% fig.Position = [mod(figure_num,2)*screenwidth/2, 0, screenwidth/2, screenheight];
% subplot(2,1,1);
% plot(p2_y2);
% hold on;
% plot(y_estimated);
% axis tight;
% axes = gca;
% axes.Title.Interpreter = 'latex';
% axes.Title.String = 'Actual Output vs. Model Output';
% axes.Title.FontSize = 18;
% axes.XAxis.TickLabelInterpreter = 'latex';
% axes.XAxis.FontSize = 10;
% axes.YAxis.TickLabelInterpreter = 'latex';
% axes.YAxis.FontSize = 10;
% axes.XLabel.Interpreter = 'latex';
% axes.XLabel.String = '$k$ $[samples]$';
% axes.XLabel.FontSize = 14;
% lgd = legend('$y(k)$', '$y_{\hat{\theta}}(k)$');
% lgd.Interpreter = 'latex';
% lgd.FontSize = 12;
% lgd.Location = 'southwest';
% subplot(2,1,2);
% plot(estimation_error);
% axis tight;
% axes = gca;
% axes.Title.Interpreter = 'latex';
% axes.Title.String = 'Model Output Error';
% axes.Title.FontSize = 18;
% axes.XAxis.TickLabelInterpreter = 'latex';
% axes.XAxis.FontSize = 10;
% axes.YAxis.TickLabelInterpreter = 'latex';
% axes.YAxis.FontSize = 10;
% axes.XLabel.Interpreter = 'latex';
% axes.XLabel.String = '$k$ $[samples]$';
% axes.XLabel.FontSize = 14;
% axes.YLabel.Interpreter = 'latex';
% axes.YLabel.String = '$y(k) - y_{\hat{\theta}}(k)$';
% axes.YLabel.FontSize = 14;

estimation_error_var = var(estimation_error(:), 1);
fprintf('Improved Estimated Model ouput error variance is: %.4f.\n', estimation_error_var);
fprintf('Improved Estimated Model ouput error is: %.4f.\n', mean(estimation_error(:).^2));
p2_a_ex1 = thetaIV(1:3);
p2_b_ex1 = thetaIV(4:5);
%% Part 2
% Compute parameter estimates using delayed inputs as instruments
%getting Instrumental Variables Now
%getting Instrumental Variables Now
fprintf('------------------------------------------------------------------\n');
fprintf('--------------------TASK TWO--------------------------------------\n');
fprintf('------------------------------------------------------------------\n');
fprintf('The estimate obtained with the delayed inputs instrumental variables is unbiased indeed since,\n');
fprintf('since the instruments have no correlation with the noise (because they are the inputs) and high correlation with the output\n');
fprintf('However, due to the fact that we are using more data now (stacked above each other), the estimated error is expected to be lower.\n');
N = length(p2_y2);
M = length(p2_y1);
Phi = zeros(N + M, 5);
Phi(2, :) = [-p2_y2(1) 0 0 p2_u2(1) 0];
Phi(3, :) = [-p2_y2(2) -p2_y2(1) 0 p2_u2(2) p2_u2(1)];
for k = 4 : N
    Phi(k, :) = [-p2_y2(k-1) -p2_y2(k-2) -p2_y2(k-3) p2_u2(k-1) p2_u2(k-2)];
end
Phi(2+N, :) = [-p2_y1(1) 0 0 p2_u1(1) 0];
Phi(3+N, :) = [-p2_y1(2) -p2_y1(1) 0 p2_u1(2) p2_u1(1)];
for k = 4 : M
    Phi(k+N, :) = [-p2_y1(k-1) -p2_y1(k-2) -p2_y1(k-3) p2_u1(k-1) p2_u1(k-2)];
end
eta = zeros(5, N+M);
Rk = zeros(5);
eta_y = zeros(5, 1);
eta(:,2) = [p2_u2(1); 0; 0; 0; 0];
Rk = Rk + eta(:,2) * Phi(2,:);
eta_y = eta_y + eta(:,2) * p2_y2(2);
eta(:,3) = [p2_u2(2); p2_u2(1); 0; 0; 0];
Rk = Rk + eta(:,3) * Phi(3,:);
eta_y = eta_y + eta(:,3) * p2_y2(3);
eta(:,4) = [p2_u2(3); p2_u2(2); p2_u2(1); 0; 0];
Rk = Rk + eta(:,4) * Phi(4,:);
eta_y = eta_y + eta(:,4) * p2_y2(4);
eta(:,5) = [p2_u2(4); p2_u2(3); p2_u2(2); p2_u2(1); 0];
Rk = Rk + eta(:,5) * Phi(5,:);
eta_y = eta_y + eta(:,5) * p2_y2(5);
for k = 6 : N
    eta(:,k) = [p2_u2(k-1); p2_u2(k-2); p2_u2(k-3); p2_u2(k-4); p2_u2(k-5)];
    Rk = Rk + eta(:,k) * Phi(k,:);
    eta_y = eta_y + eta(:,k) * p2_y2(k);
end

eta(:,2+N) = [p2_u1(1); 0; 0; 0; 0];
Rk = Rk + eta(:,2+N) * Phi(2+N,:);
eta_y = eta_y + eta(:,2+N) * p2_y1(2);
eta(:,3+N) = [p2_u1(2); p2_u1(1); 0; 0; 0];
Rk = Rk + eta(:,3+N) * Phi(3+N,:);
eta_y = eta_y + eta(:,3+N) * p2_y1(3);
eta(:,4+N) = [p2_u1(3); p2_u1(2); p2_u1(1); 0; 0];
Rk = Rk + eta(:,4+N) * Phi(4+N,:);
eta_y = eta_y + eta(:,4+N) * p2_y1(4);
eta(:,5+N) = [p2_u1(4); p2_u1(3); p2_u1(2); p2_u1(1); 0];
Rk = Rk + eta(:,5+N) * Phi(5+N,:);
eta_y = eta_y + eta(:,5+N) * p2_y1(5);
for k = 6 : M
    eta(:,k+N) = [p2_u1(k-1); p2_u1(k-2); p2_u1(k-3); p2_u1(k-4); p2_u1(k-5)];
    Rk = Rk + eta(:,k+N) * Phi(k+N,:);
    eta_y = eta_y + eta(:,k+N) * p2_y1(k);
end

Rk = Rk / (N + M);
eta_y = eta_y / (N + M);

thetaIV = Rk \ eta_y;


p2_a_ex2 = thetaIV(1:3);
p2_b_ex2 = thetaIV(4:5);
%% Part 3
% Compute mean squared errors using the cross-validation data set
fprintf('------------------------------------------------------------------\n');
fprintf('--------------------TASK THREE--------------------------------------\n');
fprintf('------------------------------------------------------------------\n');
fprintf('1) The estimate obtained with the delayed inputs has a lower cross validation error due to the fact that we used twice the data to estimate the second estimate\n');
fprintf('   If hypothetically we used the same amount of data for both methods, we would end up getting the same estimate.\n');
fprintf('2) then as shown in the exercise session that the two instruments can be related by [-x(t-1); -x(t-2); -x(t-3); p2_u2(k-1); p2_u2(k-2)]\n');
fprintf('   = 1/A [-B(z)u(t-1);-B(z)u(t-2);-B(z)u(t-3); A(z)u(k-1); A(z)u(k-2)] = S(-B, A)/A [u(k-1);u(k-2);u(k-3);u(k-4);u(k-5)]\n');
fprintf('   Therefore the S (Sylvester matrix) has to be invertible which will happen if the polynomials A and B have no common factor (i.e no poles and zeros cancellation)\n');
N = length(p2_u_cv);
%reconstruct tf now
a1 = p2_a_ex1(1);
a2 = p2_a_ex1(2);
a3 = p2_a_ex1(3);
b1 = p2_b_ex1(1);
b2 = p2_b_ex1(2);
z = tf('z');
G = ((b1 / z) + (b2 / z^2)) / (1 + a1 / z + a2 / z^2 + a3 / z^3);
y_estimated_theta_1 = lsim(G, p2_u_cv);
a1 = p2_a_ex2(1);
a2 = p2_a_ex2(2);
a3 = p2_a_ex2(3);
b1 = p2_b_ex2(1);
b2 = p2_b_ex2(2);
z = tf('z');
G = ((b1 / z) + (b2 / z^2)) / (1 + a1 / z + a2 / z^2 + a3 / z^3);
y_estimated_theta_2 = lsim(G, p2_u_cv);
estimation_error_1 = p2_y_cv - y_estimated_theta_1;
estimation_error_2 = p2_y_cv - y_estimated_theta_2;
p2_mse_ex1 = mean(estimation_error_1(:).^2); 
p2_mse_ex2 = mean(estimation_error_2(:).^2);
end

